{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scoringrules: probabilistic forecast evaluation","text":"<p>Scoringrules is a python library for evaluating probabilistic forecasts by computing scoring rules and other diagnostic quantities. It aims to assist forecasting practitioners by providing a set of tools based the scientific literature and via its didactic approach.</p>"},{"location":"api/brier/","title":"Brier Score","text":""},{"location":"api/brier/#scoringrules.brier.brier_score","title":"<code>scoringrules.brier.brier_score(forecasts: NDArray, observations: NDArray)</code>","text":"<p>Compute the Brier Score (BS).</p> <p>The BS is formulated as</p> \\[BS(f, y) = (f - y)^2,\\] <p>where \\(f \\in [0, 1]\\) is the predicted probability of an event and \\(y \\in \\{0, 1\\}\\) the actual outcome.</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>NDArray</code> <p>Forecasted probabilities between 0 and 1.</p> required <code>observations</code> <code>NDArray</code> <p>Observed outcome, either 0 or 1.</p> required <p>Returns:</p> Name Type Description <code>brier_score</code> <code>NDArray</code> <p>The computed Brier Score.</p> Source code in <code>scoringrules/brier.py</code> <pre><code>def brier_score(forecasts: NDArray, observations: NDArray):\nr\"\"\"\n    Compute the Brier Score (BS).\n\n    The BS is formulated as\n\n    $$BS(f, y) = (f - y)^2,$$\n\n    where $f \\in [0, 1]$ is the predicted probability of an event and $y \\in \\{0, 1\\}$ the actual outcome.\n\n    Parameters\n    ----------\n    forecasts : NDArray\n        Forecasted probabilities between 0 and 1.\n    observations: NDArray\n        Observed outcome, either 0 or 1.\n\n    Returns\n    -------\n    brier_score : NDArray\n        The computed Brier Score.\n\n    \"\"\"\n    forecasts, observations = np.array(forecasts), np.asarray(observations)\n\n    if (forecasts &lt; 0.0).any() or (forecasts &gt; (1.0 + EPSILON)).any():\n        raise ValueError(\"Forecasted probabilities must be within 0 and 1.\")\n\n    if not set(np.unique(observations[~np.isnan(observations)])) &lt;= {0, 1}:\n        raise ValueError(\"Observations must be 0, 1, or NaN\")\n\n    return (forecasts - observations) ** 2\n</code></pre>"},{"location":"api/crps/","title":"Continuous Ranked Probability Score","text":"<p>Formally, the CRPS is expressed as</p> \\[\\text{CRPS}(F, y) = \\int_{\\mathbb{R}}[F(x)-\\mathbb{1}\\{y \\le x\\}]^2 dx\\] <p>where \\(F(x) = P(X&lt;x)\\) is the forecast CDF and \\(\\mathbb{1}\\{x \\le y\\}\\) the empirical CDF of the scalar observation \\(y\\). \\(\\mathbb{1}\\) is the indicator function. The CRPS can also be viewed as the Brier score integrated over all real-valued thresholds.</p> <p></p>"},{"location":"api/crps/#ensemble-based-estimators","title":"Ensemble-based estimators","text":"<p>When the true forecast CDF is not fully known, but represented by a finite ensemble, the CRPS can be estimated with some error. Several estimators exist and they are implemented in <code>scoringrules</code>. For a thorough review of CRPS estimators and their respective biases, refer to Zamo and Naveau (2018)1 and Jordan (2016)2.</p>"},{"location":"api/crps/#integral-form-int","title":"Integral form (INT)","text":"<p>The numerical approximation of the cumulative integral over the finite ensemble.</p> \\[ \\text{CRPS}_{\\text{INT}}(M, y) = \\int_{\\mathbb{R}} \\left[ \\frac{1}{M} \\sum_{i=1}^M \\mathbb{1}\\{x_i \\le x \\} - \\mathbb{1}\\{y \\le x\\}  \\right] ^2 dx \\] <p>Runs with \\(O(m\\cdot\\mathrm{log}m)\\) complexity, including the sorting of the ensemble.</p>"},{"location":"api/crps/#energy-form-nrg","title":"Energy form (NRG)","text":"<p>Introduced by Gneiting and Raftery (2007)3:</p> \\[ \\text{CRPS}_{\\text{NRG}}(M, y) = \\frac{1}{M} \\sum_{i=1}^{M}|x_i - y| - \\frac{1}{2 M^2}\\sum_{i,j=1}^{M}|x_i - x_j|\\] <p>It is called the \"energy form\" because it is the one-dimensional case of the Energy Score.</p> <p>Runs with \\(O(m^2)\\) complexity.</p>"},{"location":"api/crps/#quantile-decomposition-form-qd","title":"Quantile decomposition form (QD)","text":"<p>Introduced by Jordan (2016)2:</p> \\[\\mathrm{CRPS}_{\\mathrm{QD}}(M, y) = \\frac{2}{M^2} \\sum_{i=1}^{M}(x_i - y)\\left[M\\mathbb{1}\\{y \\le x_i\\} - i + \\frac{1}{2} \\right]\\] <p>Runs with \\(O(m\\cdot\\mathrm{log}m)\\) complexity, including the sorting of the ensemble.</p>"},{"location":"api/crps/#probability-weighted-moment-form-pwm","title":"Probability weighted moment form (PWM)","text":"<p>Introduced by Taillardat et al. (2016)4:</p> \\[\\mathrm{CRPS}_{\\mathrm{NRG}}(M, y) = \\frac{1}{M} \\sum_{i=1}^{M}|x_i - y| + \\hat{\\beta_0} - 2\\hat{\\beta_1},\\] <p>where \\(\\hat{\\beta_0} = \\frac{1}{M} \\sum_{i=1}^{M}x_i\\) and \\(\\hat{\\beta_1} = \\frac{1}{M(M-1)} \\sum_{i=1}^{M}(i - 1)x_i\\). Runs with \\(O(m\\cdot\\mathrm{log}m)\\) complexity, including the sorting of the ensemble.</p> <p></p>"},{"location":"api/crps/#scoringrules.crps.ensemble","title":"<code>scoringrules.crps.ensemble(forecasts: NDArray, observations: NDArray, axis: int = -1, sorted_ensemble: bool = False, estimator: str = 'int') -&gt; NDArray</code>","text":"<p>Estimate the Continuous Ranked Probability Score (CRPS) for a finite ensemble.</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>NDArray</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the last axis.</p> required <code>observations</code> <code>NDArray</code> <p>The observed values.</p> required <code>axis</code> <code>int</code> <p>The axis corresponding to the example. Default is the last axis.</p> <code>-1</code> <code>sorted_ensemble</code> <code>bool</code> <p>Boolean indicating whether the ensemble members are already in ascending order. Default is False.</p> <code>False</code> <code>estimator</code> <code>str</code> <p>Indicates the CRPS estimator to be used.</p> <code>'int'</code> <p>Returns:</p> Name Type Description <code>crps</code> <code>NDArray</code> <p>The CRPS between the forecast ensemble and obs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; crps.ensemble(pred, obs)\n</code></pre> Source code in <code>scoringrules/crps.py</code> <pre><code>def ensemble(\n    forecasts: NDArray,\n    observations: NDArray,\n    axis: int = -1,\n    sorted_ensemble: bool = False,\n    estimator: str = \"int\",\n) -&gt; NDArray:\nr\"\"\"Estimate the Continuous Ranked Probability Score (CRPS) for a finite ensemble.\n\n    Parameters\n    ----------\n    forecasts: NDArray\n        The predicted forecast ensemble, where the ensemble dimension is by default\n        represented by the last axis.\n    observations: NDArray\n        The observed values.\n    axis: int, optional\n        The axis corresponding to the example. Default is the last axis.\n    sorted_ensemble: bool, optional\n        Boolean indicating whether the ensemble members are already in ascending order.\n        Default is False.\n    estimator: str\n        Indicates the CRPS estimator to be used.\n\n    Returns\n    -------\n    crps: NDArray\n        The CRPS between the forecast ensemble and obs.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from scoringrules import crps\n    &gt;&gt;&gt; crps.ensemble(pred, obs)\n    \"\"\"\n    if not sorted_ensemble and estimator != \"nrg\":\n        forecasts = np.sort(forecasts, axis=axis)\n\n    if estimator == \"int\":\n        out = _crps_ensemble_int_gufunc(forecasts, observations)\n    elif estimator == \"qd\":\n        out = _crps_ensemble_qd_gufunc(forecasts, observations)\n    elif estimator == \"nrg\":\n        out = _crps_ensemble_nrg_gufunc(forecasts, observations)\n    else:\n        raise ValueError(\"{estimator} is not a valid estimator\")\n\n    return out\n</code></pre>"},{"location":"api/crps/#analytical-formulations","title":"Analytical formulations","text":"<ol> <li> <p>Micha\u00ebl Zamo and Philippe Naveau. Estimation of the Continuous Ranked Probability Score with Limited Information and Applications to Ensemble Weather Forecasts. Mathematical Geosciences, 2018. URL: https://doi.org/10.1007/s11004-017-9709-7, doi:10.1007/s11004-017-9709-7.\u00a0\u21a9</p> </li> <li> <p>Alexander Jordan. Facets of forecast evaluation. PhD thesis, Karlsruher Institut f\u00fcr Technologie (KIT), 2016. doi:10.5445/IR/1000063629.\u00a0\u21a9\u21a9</p> </li> <li> <p>Tilmann Gneiting and Adrian E Raftery. Strictly Proper Scoring Rules, Prediction, and Estimation. Journal of the American Statistical Association, 2007. URL: https://doi.org/10.1198/016214506000001437, doi:10.1198/016214506000001437.\u00a0\u21a9</p> </li> <li> <p>Maxime Taillardat, Olivier Mestre, Micha\u00ebl Zamo, and Philippe Naveau. Calibrated Ensemble Forecasts Using Quantile Regression Forests and Ensemble Model Output Statistics. Monthly Weather Review, 2016. URL: http://journals.ametsoc.org/doi/10.1175/MWR-D-15-0260.1, doi:10.1175/MWR-D-15-0260.1.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/crps/#scoringrules.crps.normal","title":"<code>scoringrules.crps.normal(mu: NDArray, sigma: NDArray, observation: NDArray) -&gt; NDArray</code>","text":"<p>Compute the closed form of the CRPS for the normal distribution.</p> <p>TODO: https://journals.ametsoc.org/view/journals/mwre/133/5/mwr2904.1.xml</p> <p>It is based on the following formulation</p> \\[ \\mathrm{CRPS}(\\mathcal{N}(\\mu, \\sigma), y) = \\sigma \\Bigl\\{ \\omega [\\Phi(\u03c9) - 1] + 2 \\phi(\\omega) - \\frac{1}{\\sqrt{\\pi}} \\Bigl\\} \\] <p>where \\(\\Phi(\u03c9)\\) and \\(\\phi(\u03c9)\\) are respectively the CDF and PDF of the standard normal distribution at the normalized prediction error \\(\\omega = \\frac{y - \\mu}{\\sigma}\\).</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>NDArray</code> <p>Mean of the forecast normal distribution.</p> required <code>sigma</code> <code>NDArray</code> <p>Standard deviation of the forecast normal distribution.</p> required <code>observation</code> <code>NDArray</code> <p>The observed values.</p> required <p>Returns:</p> Name Type Description <code>crps</code> <code>array_like</code> <p>The CRPS between Normal(mu, sigma) and obs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; crps.normal(0.1, 0.4, 0.0)\n</code></pre> Source code in <code>scoringrules/crps.py</code> <pre><code>def normal(mu: NDArray, sigma: NDArray, observation: NDArray) -&gt; NDArray:\nr\"\"\"Compute the closed form of the CRPS for the normal distribution.\n\n    TODO: https://journals.ametsoc.org/view/journals/mwre/133/5/mwr2904.1.xml\n\n    It is based on the following formulation\n\n    $$ \\mathrm{CRPS}(\\mathcal{N}(\\mu, \\sigma), y) = \\sigma \\Bigl\\{ \\omega [\\Phi(\u03c9) - 1] + 2 \\phi(\\omega) - \\frac{1}{\\sqrt{\\pi}} \\Bigl\\} $$\n\n    where $\\Phi(\u03c9)$ and $\\phi(\u03c9)$ are respectively the CDF and PDF of the standard normal\n    distribution at the normalized prediction error $\\omega = \\frac{y - \\mu}{\\sigma}$.\n\n    Parameters\n    ----------\n    mu: NDArray\n        Mean of the forecast normal distribution.\n    sigma: NDArray\n        Standard deviation of the forecast normal distribution.\n    observation: NDArray\n        The observed values.\n\n    Returns\n    -------\n    crps: array_like\n        The CRPS between Normal(mu, sigma) and obs.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from scoringrules import crps\n    &gt;&gt;&gt; crps.normal(0.1, 0.4, 0.0)\n    \"\"\"\n    \u03c9 = (observation - mu) / sigma\n    return sigma * (\n        \u03c9 * (2 * norm.cdf(\u03c9, 0, 1) - 1) + 2 * norm.pdf(\u03c9, 0, 1) - INV_SQRT_PI\n    )\n</code></pre>"},{"location":"api/crps/#scoringrules.crps.lognormal","title":"<code>scoringrules.crps.lognormal(mulog: NDArray, sigmalog: NDArray, observation: NDArray) -&gt; NDArray</code>","text":"<p>Compute the closed form of the CRPS for the lognormal distribution.</p> <p>TODO: https://rmets.onlinelibrary.wiley.com/doi/full/10.1002/qj.2521</p> \\[ \\mathrm{CRPS}(\\mathrm{log}\\mathcal{N}(\\mu, \\sigma), y) = y [2 \\Phi(y) - 1] - 2 \\mathrm{exp}(\\mu + \\frac{\\sigma^2}{2}) \\left[ \\Phi(\\omega - \\sigma) + \\Phi(\\frac{\\sigma}{\\sqrt{2}}) \\right]\\] <p>where \\(\\Phi\\) is the CDF of the standard normal distribution and \\(\\omega = \\frac{\\mathrm{log}y - \\mu}{\\sigma}\\).</p> <p>Parameters:</p> Name Type Description Default <code>mulog</code> <code>NDArray</code> <p>Mean of the normal underlying distribution.</p> required <code>sigmalog</code> <code>NDArray</code> <p>Standard deviation of the underlying normal distribution.</p> required <p>Returns:</p> Name Type Description <code>crps</code> <code>NDArray</code> <p>The CRPS between Lognormal(mu, sigma) and obs.</p>"},{"location":"api/crps/#scoringrules.crps.lognormal--notes","title":"Notes","text":"<p>The mean and standard deviation are not the values for the distribution itself, but of the underlying normal distribution it is derived from.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; crps.lognormal(0.1, 0.4, 0.0)\n</code></pre> Source code in <code>scoringrules/crps.py</code> <pre><code>def lognormal(mulog: NDArray, sigmalog: NDArray, observation: NDArray) -&gt; NDArray:\nr\"\"\"Compute the closed form of the CRPS for the lognormal distribution.\n\n    TODO: https://rmets.onlinelibrary.wiley.com/doi/full/10.1002/qj.2521\n\n    $$ \\mathrm{CRPS}(\\mathrm{log}\\mathcal{N}(\\mu, \\sigma), y) =\n    y [2 \\Phi(y) - 1] - 2 \\mathrm{exp}(\\mu + \\frac{\\sigma^2}{2})\n    \\left[ \\Phi(\\omega - \\sigma) + \\Phi(\\frac{\\sigma}{\\sqrt{2}}) \\right]$$\n\n    where $\\Phi$ is the CDF of the standard normal distribution and\n    $\\omega = \\frac{\\mathrm{log}y - \\mu}{\\sigma}$.\n\n\n\n    Parameters\n    ----------\n    mulog: NDArray\n        Mean of the normal underlying distribution.\n    sigmalog: NDArray\n        Standard deviation of the underlying normal distribution.\n\n    Returns\n    -------\n    crps: NDArray\n        The CRPS between Lognormal(mu, sigma) and obs.\n\n    Notes\n    -----\n    The mean and standard deviation are not the values for the distribution itself,\n    but of the underlying normal distribution it is derived from.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from scoringrules import crps\n    &gt;&gt;&gt; crps.lognormal(0.1, 0.4, 0.0)\n    \"\"\"\n    \u03c9 = (np.log(observation) - mulog) / sigmalog\n    ex = 2 * np.exp(mulog + sigmalog**2 / 2)\n    crps = observation * (2 * norm.cdf(\u03c9, 0, 1) - 1) - ex * (\n        norm.cdf(\u03c9 - sigmalog, 0, 1) + norm.cdf(sigmalog / np.sqrt(2), 0, 1) - 1\n    )\n    return crps\n</code></pre>"}]}