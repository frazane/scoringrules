{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scoringrules: probabilistic forecast evaluation","text":"<p>Scoringrules is a python library for evaluating probabilistic forecasts by computing scoring rules and other diagnostic quantities. It aims to assist forecasting practitioners by providing a set of tools based the scientific literature and via its didactic approach.</p>"},{"location":"api/brier/","title":"Brier Score","text":""},{"location":"api/brier/#scoringrules.brier_score","title":"<code>scoringrules.brier_score(forecasts: ArrayLike, observations: ArrayLike, /, *, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the Brier Score (BS).</p> <p>The BS is formulated as</p> \\[BS(f, y) = (f - y)^2,\\] <p>where \\(f \\in [0, 1]\\) is the predicted probability of an event and \\(y \\in \\{0, 1\\}\\) the actual outcome.</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>NDArray</code> <p>Forecasted probabilities between 0 and 1.</p> required <code>observations</code> <code>ArrayLike</code> <p>Observed outcome, either 0 or 1.</p> required <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>brier_score</code> <code>NDArray</code> <p>The computed Brier Score.</p>"},{"location":"api/error_spread/","title":"Error Spread Score","text":""},{"location":"api/error_spread/#scoringrules.error_spread_score","title":"<code>scoringrules.error_spread_score(forecasts: Array, observations: ArrayLike, /, axis: int = -1, *, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the error-spread score (ESS) for a finite ensemble.</p> <p>The error spread score (Christensen et al., 2015) is given by:</p> \\[ESS = \\left(s^2 - e^2 - e \\cdot s \\cdot g\\right)^2\\] <p>where the mean \\(m\\), variance \\(s^2\\), and skewness \\(g\\) of the ensemble forecast of size \\(F\\) are computed as follows:</p> \\[m = \\frac{1}{F} \\sum_{f=1}^{F} X_f, \\quad s^2 = \\frac{1}{F-1} \\sum_{f=1}^{F} (X_f - m)^2, \\quad g = \\frac{F}{(F-1)(F-2)} \\sum_{f=1}^{F} \\left(\\frac{X_f - m}{s}\\right)^3\\] <p>The error in the ensemble mean \\(e\\) is calculated as \\(e = m - y\\), where \\(y\\) is the observed value.</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the last axis.</p> required <code>observations</code> <code>ArrayLike</code> <p>The observed values.</p> required <code>axis</code> <code>int</code> <p>The axis corresponding to the ensemble. Default is the last axis.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Type Description <code>-Array</code> <p>An array of error spread scores for each ensemble forecast, which should be averaged to get meaningful values.</p>"},{"location":"api/logarithmic/","title":"Logarithmic Score","text":""},{"location":"api/logarithmic/#scoringrules.logs_normal","title":"<code>scoringrules.logs_normal(mu: ArrayLike, sigma: ArrayLike, observation: ArrayLike, /, *, negative: bool = True, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the logarithmic score (LS) for the normal distribution.</p> <p>This score is equivalent to the negative log likelihood (if <code>negative = True</code>)</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>ArrayLike</code> <p>Mean of the forecast normal distribution.</p> required <code>sigma</code> <code>ArrayLike</code> <p>Standard deviation of the forecast normal distribution.</p> required <code>observation</code> <code>ArrayLike</code> <p>The observed values.</p> required <code>backend</code> <code>Backend</code> <p>The backend used for computations.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ls</code> <code>array_like</code> <p>The LS between Normal(mu, sigma) and obs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import scoringrules as sr\n&gt;&gt;&gt; sr.logs_normal(0.1, 0.4, 0.0)\n&gt;&gt;&gt; 0.033898\n</code></pre>"},{"location":"api/crps/","title":"Continuous Ranked Probability Score","text":"<p>Formally, the CRPS is expressed as</p> \\[\\text{CRPS}(F, y) = \\int_{\\mathbb{R}}[F(x)-\\mathbb{1}\\{y \\le x\\}]^2 dx\\] <p>where \\(F(x) = P(X&lt;x)\\) is the forecast CDF and \\(\\mathbb{1}\\{x \\le y\\}\\) the empirical CDF of the scalar observation \\(y\\). \\(\\mathbb{1}\\) is the indicator function. The CRPS can also be viewed as the Brier score integrated over all real-valued thresholds.</p> <p></p>"},{"location":"api/crps/#ensemble-based-estimators","title":"Ensemble-based estimators","text":"<p>When the true forecast CDF is not fully known, but represented by a finite ensemble, the CRPS can be estimated with some error. Several estimators exist and they are implemented in <code>scoringrules</code>. For a thorough review of CRPS estimators and their respective biases, refer to Zamo and Naveau (2018)<sup>1</sup> and Jordan (2016)<sup>2</sup>.</p>"},{"location":"api/crps/#integral-form-int","title":"Integral form (INT)","text":"<p>The numerical approximation of the cumulative integral over the finite ensemble.</p> \\[ \\text{CRPS}_{\\text{INT}}(M, y) = \\int_{\\mathbb{R}} \\left[ \\frac{1}{M} \\sum_{i=1}^M \\mathbb{1}\\{x_i \\le x \\} - \\mathbb{1}\\{y \\le x\\}  \\right] ^2 dx \\] <p>Runs with \\(O(m\\cdot\\mathrm{log}m)\\) complexity, including the sorting of the ensemble.</p>"},{"location":"api/crps/#energy-form-nrg","title":"Energy form (NRG)","text":"<p>Introduced by Gneiting and Raftery (2007)<sup>3</sup>:</p> \\[ \\text{CRPS}_{\\text{NRG}}(M, y) = \\frac{1}{M} \\sum_{i=1}^{M}|x_i - y| - \\frac{1}{2 M^2}\\sum_{i,j=1}^{M}|x_i - x_j|\\] <p>It is called the \"energy form\" because it is the one-dimensional case of the Energy Score.</p> <p>Runs with \\(O(m^2)\\) complexity.</p>"},{"location":"api/crps/#quantile-decomposition-form-qd","title":"Quantile decomposition form (QD)","text":"<p>Introduced by Jordan (2016)<sup>2</sup>:</p> \\[\\mathrm{CRPS}_{\\mathrm{QD}}(M, y) = \\frac{2}{M^2} \\sum_{i=1}^{M}(x_i - y)\\left[M\\mathbb{1}\\{y \\le x_i\\} - i + \\frac{1}{2} \\right]\\] <p>Runs with \\(O(m\\cdot\\mathrm{log}m)\\) complexity, including the sorting of the ensemble.</p>"},{"location":"api/crps/#probability-weighted-moment-form-pwm","title":"Probability weighted moment form (PWM)","text":"<p>Introduced by Taillardat et al. (2016)<sup>4</sup>:</p> \\[\\mathrm{CRPS}_{\\mathrm{NRG}}(M, y) = \\frac{1}{M} \\sum_{i=1}^{M}|x_i - y| + \\hat{\\beta_0} - 2\\hat{\\beta_1},\\] <p>where \\(\\hat{\\beta_0} = \\frac{1}{M} \\sum_{i=1}^{M}x_i\\) and \\(\\hat{\\beta_1} = \\frac{1}{M(M-1)} \\sum_{i=1}^{M}(i - 1)x_i\\). Runs with \\(O(m\\cdot\\mathrm{log}m)\\) complexity, including the sorting of the ensemble.</p> <p></p> <ol> <li> <p>Micha\u00ebl Zamo and Philippe Naveau. Estimation of the Continuous Ranked Probability Score with Limited Information and Applications to Ensemble Weather Forecasts. Mathematical Geosciences, 2018. URL: https://doi.org/10.1007/s11004-017-9709-7, doi:10.1007/s11004-017-9709-7.\u00a0\u21a9</p> </li> <li> <p>Alexander Jordan. Facets of forecast evaluation. PhD thesis, Karlsruher Institut f\u00fcr Technologie (KIT), 2016. doi:10.5445/IR/1000063629.\u00a0\u21a9\u21a9</p> </li> <li> <p>Tilmann Gneiting and Adrian E Raftery. Strictly Proper Scoring Rules, Prediction, and Estimation. Journal of the American Statistical Association, 2007. URL: https://doi.org/10.1198/016214506000001437, doi:10.1198/016214506000001437.\u00a0\u21a9</p> </li> <li> <p>Maxime Taillardat, Olivier Mestre, Micha\u00ebl Zamo, and Philippe Naveau. Calibrated Ensemble Forecasts Using Quantile Regression Forests and Ensemble Model Output Statistics. Monthly Weather Review, 2016. URL: http://journals.ametsoc.org/doi/10.1175/MWR-D-15-0260.1, doi:10.1175/MWR-D-15-0260.1.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/crps/analytical/","title":"Analytical formulations","text":""},{"location":"api/crps/analytical/#scoringrules.crps_normal","title":"<code>scoringrules.crps_normal(mu: ArrayLike, sigma: ArrayLike, observation: ArrayLike, /, *, backend: Backend = None) -&gt; ArrayLike</code>","text":"<p>Compute the closed form of the CRPS for the normal distribution.</p> <p>It is based on the following formulation from Geiting et al. (2005):</p> \\[ \\mathrm{CRPS}(\\mathcal{N}(\\mu, \\sigma), y) = \\sigma \\Bigl\\{ \\omega [\\Phi(\u03c9) - 1] + 2 \\phi(\\omega) - \\frac{1}{\\sqrt{\\pi}} \\Bigl\\},\\] <p>where \\(\\Phi(\u03c9)\\) and \\(\\phi(\u03c9)\\) are respectively the CDF and PDF of the standard normal distribution at the normalized prediction error \\(\\omega = \\frac{y - \\mu}{\\sigma}\\).</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>ArrayLike</code> <p>Mean of the forecast normal distribution.</p> required <code>sigma</code> <code>ArrayLike</code> <p>Standard deviation of the forecast normal distribution.</p> required <code>observation</code> <code>ArrayLike</code> <p>The observed values.</p> required <p>Returns:</p> Name Type Description <code>crps</code> <code>array_like</code> <p>The CRPS between Normal(mu, sigma) and obs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; crps.normal(0.1, 0.4, 0.0)\n</code></pre>"},{"location":"api/crps/analytical/#scoringrules.crps_lognormal","title":"<code>scoringrules.crps_lognormal(mulog: ArrayLike, sigmalog: ArrayLike, observation: ArrayLike, backend: Backend = None) -&gt; ArrayLike</code>","text":"<p>Compute the closed form of the CRPS for the lognormal distribution.</p> <p>It is based on the formulation introduced by Baran and Lerch (2015)</p> \\[ \\mathrm{CRPS}(\\mathrm{log}\\mathcal{N}(\\mu, \\sigma), y) = y [2 \\Phi(y) - 1] - 2 \\mathrm{exp}(\\mu + \\frac{\\sigma^2}{2}) \\left[ \\Phi(\\omega - \\sigma) + \\Phi(\\frac{\\sigma}{\\sqrt{2}}) \\right]\\] <p>where \\(\\Phi\\) is the CDF of the standard normal distribution and \\(\\omega = \\frac{\\mathrm{log}y - \\mu}{\\sigma}\\).</p> <p>Parameters:</p> Name Type Description Default <code>mulog</code> <code>ArrayLike</code> <p>Mean of the normal underlying distribution.</p> required <code>sigmalog</code> <code>ArrayLike</code> <p>Standard deviation of the underlying normal distribution.</p> required <p>Returns:</p> Name Type Description <code>crps</code> <code>ArrayLike</code> <p>The CRPS between Lognormal(mu, sigma) and obs.</p>"},{"location":"api/crps/analytical/#scoringrules.crps_lognormal--notes","title":"Notes","text":"<p>The mean and standard deviation are not the values for the distribution itself, but of the underlying normal distribution it is derived from.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; crps.lognormal(0.1, 0.4, 0.0)\n</code></pre>"},{"location":"api/crps/ensemble/","title":"Ensemble-based estimation","text":""},{"location":"api/crps/ensemble/#scoringrules.crps_ensemble","title":"<code>scoringrules.crps_ensemble(forecasts: Array, observations: ArrayLike, /, axis: int = -1, *, sorted_ensemble: bool = False, estimator: str = 'pwm', backend: Backend = None) -&gt; Array</code>","text":"<p>Estimate the Continuous Ranked Probability Score (CRPS) for a finite ensemble.</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the last axis.</p> required <code>observations</code> <code>ArrayLike</code> <p>The observed values.</p> required <code>axis</code> <code>int</code> <p>The axis corresponding to the ensemble. Default is the last axis.</p> <code>-1</code> <code>sorted_ensemble</code> <code>bool</code> <p>Boolean indicating whether the ensemble members are already in ascending order. Default is False.</p> <code>False</code> <code>estimator</code> <code>str</code> <p>Indicates the CRPS estimator to be used.</p> <code>'pwm'</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>crps</code> <code>ArrayLike</code> <p>The CRPS between the forecast ensemble and obs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; crps.ensemble(pred, obs)\n</code></pre>"},{"location":"api/crps/weighted/","title":"Weighted versions","text":""},{"location":"api/crps/weighted/#scoringrules.owcrps_ensemble","title":"<code>scoringrules.owcrps_ensemble(forecasts: Array, observations: ArrayLike, w_func: tp.Callable[[ArrayLike], ArrayLike], /, axis: int = -1, *, estimator: tp.Literal['nrg'] = 'nrg', backend: Backend = None) -&gt; Array</code>","text":"<p>Estimate the Outcome-Weighted Continuous Ranked Probability Score (owCRPS) for a finite ensemble.</p> <p>Computation is performed using the ensemble representation of the owCRPS in Allen et al. (2022):</p> \\[ \\mathrm{owCRPS}(F_{ens}, y) = \\frac{1}{M \\bar{w}} \\sum_{m = 1}^{M} |x_{m} - y|w(x_{m})w(y) - \\frac{1}{2 M^{2} \\bar{w}^{2}} \\sum_{m = 1}^{M} \\sum_{j = 1}^{M} |x_{m} - x_{j}|w(x_{m})w(x_{j})w(y),\\] <p>where \\(F_{ens}(x) = \\sum_{m=1}^{M} 1\\{ x_{m} \\leq x \\}/M\\) is the empirical distribution function associated with an ensemble forecast \\(x_{1}, \\dots, x_{M}\\) with \\(M\\) members, \\(w\\) is the chosen weight function, and \\(\\bar{w} = \\sum_{m=1}^{M}w(x_{m})/M\\).</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the last axis.</p> required <code>observations</code> <code>ArrayLike</code> <p>The observed values.</p> required <code>w_func</code> <code>Callable[[ArrayLike], ArrayLike]</code> <p>Weight function used to emphasise particular outcomes.</p> required <code>axis</code> <code>int</code> <p>The axis corresponding to the ensemble. Default is the last axis.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>owcrps</code> <code>ArrayLike</code> <p>The owCRPS between the forecast ensemble and obs for the chosen weight function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; owcrps.ensemble(pred, obs)\n</code></pre>"},{"location":"api/crps/weighted/#scoringrules.twcrps_ensemble","title":"<code>scoringrules.twcrps_ensemble(forecasts: Array, observations: ArrayLike, v_func: tp.Callable[[ArrayLike], ArrayLike], /, axis: int = -1, *, estimator: str = 'pwm', sorted_ensemble: bool = False, backend: Backend = None) -&gt; Array</code>","text":"<p>Estimate the Threshold-Weighted Continuous Ranked Probability Score (twCRPS) for a finite ensemble.</p> <p>Computation is performed using the ensemble representation of the twCRPS in Allen et al. (2022):</p> \\[ \\mathrm{twCRPS}(F_{ens}, y) = \\frac{1}{M} \\sum_{m = 1}^{M} |v(x_{m}) - v(y)| - \\frac{1}{2 M^{2}} \\sum_{m = 1}^{M} \\sum_{j = 1}^{M} |v(x_{m}) - v(x_{j})|,\\] <p>where \\(F_{ens}(x) = \\sum_{m=1}^{M} 1 \\{ x_{m} \\leq x \\}/M\\) is the empirical distribution function associated with an ensemble forecast \\(x_{1}, \\dots, x_{M}\\) with \\(M\\) members, and \\(v\\) is the chaining function used to target particular outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the last axis.</p> required <code>observations</code> <code>ArrayLike</code> <p>The observed values.</p> required <code>v_func</code> <code>Callable[[ArrayLike], ArrayLike]</code> <p>Chaining function used to emphasise particular outcomes. For example, a function that only considers values above a certain threshold \\(t\\) by projecting forecasts and observations to \\(\\[t, \\inf)\\).</p> required <code>axis</code> <code>int</code> <p>The axis corresponding to the ensemble. Default is the last axis.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>twcrps</code> <code>ArrayLike</code> <p>The twCRPS between the forecast ensemble and obs for the chosen chaining function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; twcrps.ensemble(pred, obs)\n</code></pre>"},{"location":"api/crps/weighted/#scoringrules.vrcrps_ensemble","title":"<code>scoringrules.vrcrps_ensemble(forecasts: Array, observations: ArrayLike, w_func: tp.Callable[[ArrayLike], ArrayLike], /, axis: int = -1, *, estimator: tp.Literal['nrg'] = 'nrg', backend: Backend = None) -&gt; Array</code>","text":"<p>Estimate the Vertically Re-scaled Continuous Ranked Probability Score (vrCRPS) for a finite ensemble.</p> <p>Computation is performed using the ensemble representation of the vrCRPS in Allen et al. (2022):</p> \\[ \\begin{split}     \\mathrm{vrCRPS}(F_{ens}, y) = &amp; \\frac{1}{M} \\sum_{m = 1}^{M} |x_{m} - y|w(x_{m})w(y) - \\frac{1}{2 M^{2}} \\sum_{m = 1}^{M} \\sum_{j = 1}^{M} |x_{m} - x_{j}|w(x_{m})w(x_{j}) \\\\         &amp; + \\left( \\frac{1}{M} \\sum_{m = 1}^{M} |x_{m}| w(x_{m}) - |y| w(y) \\right) \\left( \\frac{1}{M} \\sum_{m = 1}^{M} w(x_{m}) - w(y) \\right), \\end{split} \\] <p>where \\(F_{ens}(x) = \\sum_{m=1}^{M} 1 \\{ x_{m} \\leq x \\}/M\\) is the empirical distribution function associated with an ensemble forecast \\(x_{1}, \\dots, x_{M}\\) with \\(M\\) members, \\(w\\) is the chosen weight function, and \\(\\bar{w} = \\sum_{m=1}^{M}w(x_{m})/M\\).</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the last axis.</p> required <code>observations</code> <code>ArrayLike</code> <p>The observed values.</p> required <code>w_func</code> <code>Callable[[ArrayLike], ArrayLike]</code> <p>Weight function used to emphasise particular outcomes.</p> required <code>axis</code> <code>int</code> <p>The axis corresponding to the ensemble. Default is the last axis.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>vrcrps</code> <code>ArrayLike</code> <p>The vrCRPS between the forecast ensemble and obs for the chosen weight function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; vrcrps.ensemble(pred, obs)\n</code></pre>"},{"location":"api/energy/","title":"Energy Score","text":"<p>The energy score (ES) is a scoring rule for evaluating multivariate probabilistic forecasts. It is defined as </p> \\[\\text{ES}(F, \\mathbf{y})= \\mathbb{E} \\| \\mathbf{X} - \\mathbf{y} \\| - \\frac{1}{2} \\mathbb{E} \\| \\mathbf{X} - \\mathbf{X}^{\\prime} \\|, \\] <p>where \\(\\mathbf{y} \\in \\mathbb{R}^{d}\\) is the multivariate observation (\\(d &gt; 1\\)), and  \\(\\mathbf{X}\\) and \\(\\mathbf{X}^{\\prime}\\) are independent random variables that follow the multivariate forecast distribution \\(F\\) (Gneiting and Raftery, 2007)<sup>1</sup>.  If the dimension \\(d\\) were equal to one, the energy score would reduce to the continuous ranked probability score (CRPS). </p> <p></p>"},{"location":"api/energy/#ensemble-forecasts","title":"Ensemble forecasts","text":"<p>While multivariate probabilistic forecasts could belong to a parametric family of  distributions, such as a multivariate normal distribution, it is more common in practice that these forecasts are ensemble forecasts; that is, the forecast is comprised of a  predictive sample \\(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{M}\\),  where each ensemble member \\(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{M} \\in \\R^{d}\\). </p> <p>In this case, the expectations in the definition of the energy score can be replaced by sample means over the ensemble members, yielding the following representation of the energy score when evaluating an ensemble forecast \\(F_{ens}\\) with \\(M\\) members:</p> \\[\\text{ES}(F_{ens}, \\mathbf{y})= \\frac{1}{M} \\sum_{m=1}^{M} \\| \\mathbf{x}_{m} - \\mathbf{y} \\| - \\frac{1}{2 M^{2}} \\sum_{m=1}^{M} \\sum_{j=1}^{M} \\| \\mathbf{x}_{m} - \\mathbf{x}_{j} \\|. \\] <p></p>"},{"location":"api/energy/#weighted-energy-scores","title":"Weighted energy scores","text":"<p>The energy score provides a measure of overall forecast performance. However, it is often the case that certain outcomes are of more interest than others, making it desirable to assign more weight to these outcomes when evaluating forecast performance. This can be  achieved using weighted scoring rules. Weighted scoring rules typically introduce a weight function into conventional scoring rules, and users can choose the weight function depending on what outcomes they want to emphasise. Allen et al. (2022)<sup>2</sup>  discuss three weighted versions of the energy score. These are all available in <code>scoringrules</code>. </p> <p>Firstly, the outcome-weighted energy score (originally introduced by Holzmann and Klar (2014)<sup>3</sup>)  is defined as </p> \\[\\text{owES}(F, \\mathbf{y}; w)= \\frac{1}{\\bar{w}} \\mathbb{E} \\| \\mathbf{X} - \\mathbf{y} \\| w(\\mathbf{X}) w(\\mathbf{y}) - \\frac{1}{2 \\bar{w}^{2}} \\mathbb{E} \\| \\mathbf{X} - \\mathbf{X}^{\\prime} \\| w(\\mathbf{X})w(\\mathbf{X}^{\\prime})w(\\mathbf{y}), \\] <p>where \\(w : \\mathbb{R}^{d} \\to [0, \\infty)\\) is the non-negative weight function used to  target particular multivariate outcomes, and \\(\\bar{w} = \\mathbb{E}[w(X)]\\). As before, \\(\\mathbf{X}, \\mathbf{X}^{\\prime} \\sim F\\) are independent.</p> <p>Secondly, Allen et al. (2022) introduced the threshold-weighted energy score as</p> \\[\\text{twES}(F, \\mathbf{y}; v)= \\mathbb{E} \\| v(\\mathbf{X}) - v(\\mathbf{y}) \\| - \\frac{1}{2} \\mathbb{E} \\| v(\\mathbf{X}) - v(\\mathbf{X}^{\\prime}) \\|, \\] <p>where \\(v : \\mathbb{R}^{d} \\to \\mathbb{R}^{d}\\) is a so-called chaining function. The threshold-weighted energy score transforms the forecasts and observations according  to the chaining function \\(v\\), prior to calculating the unweighted energy score. Choosing a chaining function is generally more difficult than choosing a weight function when emphasising particular outcomes.</p> <p>As an alternative, the vertically re-scaled energy score is defined as </p> \\[\\text{vrES}(F, \\mathbf{y}; w, \\mathbf{x}_{0})= \\mathbb{E} \\| \\mathbf{X} - \\mathbf{y} \\| w(\\mathbf{X}) w(\\mathbf{y}) - \\frac{1}{2} \\mathbb{E} \\| \\mathbf{X} - \\mathbf{X}^{\\prime} \\| w(\\mathbf{X})w(\\mathbf{X}^{\\prime}) + \\left( \\mathbb{E} \\| \\mathbf{X} - \\mathbf{x}_{0} \\| w(\\mathbf{X}) - \\| \\mathbf{y} - \\mathbf{x}_{0} \\| w(\\mathbf{y}) \\right) \\left(\\mathbb{E}[w(\\mathbf{X})] - w(\\mathbf{y}) \\right), \\] <p>where \\(w : \\mathbb{R}^{d} \\to [0, \\infty)\\) is the non-negative weight function used to  target particular multivariate outcomes, and \\(\\mathbf{x}_{0} \\in \\mathbb{R}^{d}\\). Typically, \\(\\mathbf{x}_{0}\\) is chosen to be zero.</p> <p>Each of these weighted energy scores targets particular outcomes in a different way.  Further details regarding the differences between these scoring rules, as well as choices  for the weight and chaining functions, can be found in Allen et al. (2022). The weighted energy scores can easily be computed for ensemble forecasts by replacing the expectations with sample means over the ensemble members.</p> <p></p> <ol> <li> <p>Tilmann Gneiting and Adrian E Raftery. Strictly Proper Scoring Rules, Prediction, and Estimation. Journal of the American Statistical Association, 2007. URL: https://doi.org/10.1198/016214506000001437, doi:10.1198/016214506000001437.\u00a0\u21a9</p> </li> <li> <p>Sam Allen, David Ginsbourger, and Johanna Ziegel. Evaluating forecasts for high-impact events using transformed kernel scores. arXiv preprint arXiv:2202.12732, 2022.\u00a0\u21a9</p> </li> <li> <p>Hajo Holzmann and Bernhard Klar. Focusing on regions of interest in forecast evaluation. The Annals of Applied Statistics, 11:2404\u20132431, 2017.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/energy/ensemble/","title":"Ensemble-based estimation","text":""},{"location":"api/energy/ensemble/#scoringrules.energy_score","title":"<code>scoringrules.energy_score(forecasts: Array, observations: Array, /, m_axis: int = -2, v_axis: int = -1, *, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the Energy Score for a finite multivariate ensemble.</p> <p>The Energy Score is a multivariate scoring rule expressed as</p> \\[ES(F, \\mathbf{y}) = E_{F} ||\\mathbf{X} - \\mathbf{y}|| - \\frac{1}{2}E_{F} ||\\mathbf{X} - \\mathbf{X'}||,\\] <p>where \\(\\mathbf{X}\\) and \\(\\mathbf{X'}\\) are independent samples from \\(F\\) and \\(||\\cdot||\\) is the euclidean norm over the input dimensions (the variables).</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the second last axis and the variables dimension by the last axis.</p> required <code>observations</code> <code>Array</code> <p>The observed values, where the variables dimension is by default the last axis.</p> required <code>m_axis</code> <code>int</code> <p>The axis corresponding to the ensemble dimension on the forecasts array. Defaults to -2.</p> <code>-2</code> <code>v_axis</code> <code>int</code> <p>The axis corresponding to the variables dimension on the forecasts array (or the observations array with an extra dimension on <code>m_axis</code>). Defaults to -1.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>energy_score</code> <code>Array of shape (...)</code> <p>The computed Energy Score.</p>"},{"location":"api/energy/weighted/","title":"Weighted versions","text":""},{"location":"api/energy/weighted/#scoringrules.owenergy_score","title":"<code>scoringrules.owenergy_score(forecasts: Array, observations: Array, w_func: tp.Callable[[ArrayLike], ArrayLike], /, m_axis: int = -2, v_axis: int = -1, *, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the Outcome-Weighted Energy Score (owES) for a finite multivariate ensemble.</p> <p>Computation is performed using the ensemble representation of the owES in Allen et al. (2022):</p> \\[     \\mathrm{owES}(F_{ens}, \\mathbf{y}) = \\frac{1}{M \\bar{w}} \\sum_{m = 1}^{M} \\| \\mathbf{x}_{m} - \\mathbf{y} \\| w(\\mathbf{x}_{m}) w(\\mathbf{y}) - \\frac{1}{2 M^{2} \\bar{w}^{2}} \\sum_{m = 1}^{M} \\sum_{j = 1}^{M} \\| \\mathbf{x}_{m} - \\mathbf{x}_{j} \\| w(\\mathbf{x}_{m}) w(\\mathbf{x}_{j}) w(\\mathbf{y}), \\] <p>where \\(F_{ens}\\) is the ensemble forecast \\(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{M}\\) with \\(M\\) members, \\(\\| \\cdotp \\|\\) is the Euclidean distance, \\(w\\) is the chosen weight function, and \\(\\bar{w} = \\sum_{m=1}^{M}w(\\mathbf{x}_{m})/M\\).</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the second last axis and the variables dimension by the last axis.</p> required <code>observations</code> <code>Array</code> <p>The observed values, where the variables dimension is by default the last axis.</p> required <code>w_func</code> <code>Callable[[ArrayLike], ArrayLike]</code> <p>Weight function used to emphasise particular outcomes.</p> required <code>m_axis</code> <code>int</code> <p>The axis corresponding to the ensemble dimension. Defaults to -2.</p> <code>-2</code> <code>v_axis</code> <code>int</code> <p>The axis corresponding to the variables dimension. Defaults to -1.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>owenergy_score</code> <code>ArrayLike of shape (...)</code> <p>The computed Outcome-Weighted Energy Score.</p>"},{"location":"api/energy/weighted/#scoringrules.twenergy_score","title":"<code>scoringrules.twenergy_score(forecasts: Array, observations: Array, v_func: tp.Callable[[ArrayLike], ArrayLike], /, m_axis: int = -2, v_axis: int = -1, *, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the Threshold-Weighted Energy Score (twES) for a finite multivariate ensemble.</p> <p>Computation is performed using the ensemble representation of the twES in Allen et al. (2022):</p> \\[     \\mathrm{twES}(F_{ens}, \\mathbf{y}) = \\frac{1}{M} \\sum_{m = 1}^{M} \\| v(\\mathbf{x}_{m}) - v(\\mathbf{y}) \\| - \\frac{1}{2 M^{2}} \\sum_{m = 1}^{M} \\sum_{j = 1}^{M} \\| v(\\mathbf{x}_{m}) - v(\\mathbf{x}_{j}) \\|, \\] <p>where \\(F_{ens}\\) is the ensemble forecast \\(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{M}\\) with \\(M\\) members, \\(\\| \\cdotp \\|\\) is the Euclidean distance, and \\(v\\) is the chaining function used to target particular outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the second last axis and the variables dimension by the last axis.</p> required <code>observations</code> <code>Array</code> <p>The observed values, where the variables dimension is by default the last axis.</p> required <code>v_func</code> <code>Callable[[ArrayLike], ArrayLike]</code> <p>Chaining function used to emphasise particular outcomes.</p> required <code>m_axis</code> <code>int</code> <p>The axis corresponding to the ensemble dimension. Defaults to -2.</p> <code>-2</code> <code>v_axis</code> <code>int</code> <p>The axis corresponding to the variables dimension. Defaults to -1.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>twenergy_score</code> <code>ArrayLike of shape (...)</code> <p>The computed Threshold-Weighted Energy Score.</p>"},{"location":"api/energy/weighted/#scoringrules.vrenergy_score","title":"<code>scoringrules.vrenergy_score(forecasts: Array, observations: Array, w_func: tp.Callable[[ArrayLike], ArrayLike], /, *, m_axis: int = -2, v_axis: int = -1, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the Vertically Re-scaled Energy Score (vrES) for a finite multivariate ensemble.</p> <p>Computation is performed using the ensemble representation of the twES in Allen et al. (2022):</p> \\[ \\begin{split}     \\mathrm{vrES}(F_{ens}, \\mathbf{y}) = &amp; \\frac{1}{M} \\sum_{m = 1}^{M} \\| \\mathbf{x}_{m} - \\mathbf{y} \\| w(\\mathbf{x}_{m}) w(\\mathbf{y}) - \\frac{1}{2 M^{2}} \\sum_{m = 1}^{M} \\sum_{j = 1}^{M} \\| \\mathbf{x}_{m} - \\mathbf{x}_{j} \\| w(\\mathbf{x}_{m}) w(\\mathbf{x_{j}}) \\\\         &amp; + \\left( \\frac{1}{M} \\sum_{m = 1}^{M} \\| \\mathbf{x}_{m} \\| w(\\mathbf{x}_{m}) - \\| \\mathbf{y} \\| w(\\mathbf{y}) \\right) \\left( \\frac{1}{M} \\sum_{m = 1}^{M} w(\\mathbf{x}_{m}) - w(\\mathbf{y}) \\right), \\end{split} \\] <p>where \\(F_{ens}\\) is the ensemble forecast \\(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{M}\\) with \\(M\\) members, and \\(v\\) is the chaining function used to target particular outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the second last axis and the variables dimension by the last axis.</p> required <code>observations</code> <code>Array</code> <p>The observed values, where the variables dimension is by default the last axis.</p> required <code>w_func</code> <code>Callable[[ArrayLike], ArrayLike]</code> <p>Weight function used to emphasise particular outcomes.</p> required <code>m_axis</code> <code>int</code> <p>The axis corresponding to the ensemble dimension. Defaults to -2.</p> <code>-2</code> <code>v_axis</code> <code>int</code> <p>The axis corresponding to the variables dimension. Defaults to -1.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>vrenergy_score</code> <code>ArrayLike of shape (...)</code> <p>The computed Vertically Re-scaled Energy Score.</p>"},{"location":"api/variogram/","title":"Variogram Score","text":"<p>The varigoram score (VS) is a scoring rule for evaluating multivariate probabilistic forecasts. It is defined as </p> \\[\\text{VS}_{p}(F, \\mathbf{y})= \\sum_{i=1}^{d} \\sum_{j=1}^{d} \\left( \\mathbb{E} | X_{i} - X_{j} |^{p} - | y_{i} - y_{j} |^{p} \\right)^{2}, \\] <p>where \\(p &gt; 0\\), \\(\\mathbf{y} = (y_{1}, \\dots, y_{d}) \\in \\mathbb{R}^{d}\\) is the multivariate observation (\\(d &gt; 1\\)), and  \\(\\mathbf{X} = (X_{1}, \\dots, X_{d})\\) is a random vector that follows the multivariate forecast distribution \\(F\\) (Scheuerer and Hamill, 2015)<sup>1</sup>. The exponent \\(p\\) is typically chosen to be 0.5 or 1.</p> <p>The variogram score is less sensitive to marginal forecast performance than the energy score, and Scheuerer and Hamill (2015) argue that it should therefore be more sensitive to errors in the  forecast's dependence structure.</p> <p></p>"},{"location":"api/variogram/#ensemble-forecasts","title":"Ensemble forecasts","text":"<p>While multivariate probabilistic forecasts could belong to a parametric family of  distributions, such as a multivariate normal distribution, it is more common in practice that these forecasts are ensemble forecasts; that is, the forecast is comprised of a  predictive sample \\(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{M}\\),  where each ensemble member \\(\\mathbf{x}_{i} = (x_{i, 1}, \\dots, x_{i, d}) \\in \\R^{d}\\) for \\(i = 1, \\dots, M\\). </p> <p>In this case, the expectation in the definition of the variogram score can be replaced by a sample mean over the ensemble members, yielding the following representation of the variogram score when evaluating an ensemble forecast \\(F_{ens}\\) with \\(M\\) members:</p> \\[\\text{VS}_{p}(F_{ens}, \\mathbf{y})= \\sum_{i=1}^{d} \\sum_{j=1}^{d} \\left( \\frac{1}{M} \\sum_{m=1}^{M} | x_{m,i} - x_{m,j} |^{p} - | y_{i} - y_{j} |^{p} \\right)^{2}. \\] <p></p>"},{"location":"api/variogram/#weighted-variogram-scores","title":"Weighted variogram scores","text":"<p>It is often the case that certain outcomes are of more interest than others when evaluating  forecast performance. These outcomes can be emphasised by employing weighted scoring rules. Weighted scoring rules typically introduce a weight function into conventional scoring rules,  and users can choose the weight function depending on what outcomes they want to emphasise.  Allen et al. (2022)<sup>2</sup>  introduced three weighted versions of the variogram score.  These are all available in <code>scoringrules</code>. </p> <p>Firstly, the outcome-weighted variogram score (see also Holzmann and Klar (2014)<sup>3</sup>)  is defined as </p> \\[\\text{owVS}_{p}(F, \\mathbf{y}; w) = \\frac{1}{\\bar{w}} \\mathbb{E} [ \\rho_{p}(\\mathbf{X}, \\mathbf{y}) w(\\mathbf{X}) w(\\mathbf{y}) ] - \\frac{1}{2 \\bar{w}^{2}} \\mathbb{E} [ \\rho_{p}(\\mathbf{X}, \\mathbf{X}^{\\prime}) w(\\mathbf{X}) w(\\mathbf{X}^{\\prime}) w(\\mathbf{y}) ], \\] <p>where</p> \\[ \\rho_{p}(\\mathbf{x}, \\mathbf{z}) = \\sum_{i=1}^{d} \\sum_{j=1}^{d} \\left( |x_{i} - x_{j}|^{p} - |z_{i} - z_{j}|^{p} \\right)^{2}, \\] <p>for \\(\\mathbf{x} = (x_{1}, \\dots, x_{d}) \\in \\mathbb{R}^{d}\\) and \\(\\mathbf{z} = (z_{1}, \\dots, z_{d}) \\in \\mathbb{R}^{d}\\).</p> <p>Here, \\(w : \\mathbb{R}^{d} \\to [0, \\infty)\\) is the non-negative weight function used to  target particular multivariate outcomes, and \\(\\bar{w} = \\mathbb{E}[w(X)]\\). As before, \\(\\mathbf{X}, \\mathbf{X}^{\\prime} \\sim F\\) are independent.</p> <p>Secondly, Allen et al. (2022) introduced the threshold-weighted variogram score as</p> \\[\\text{twVS}_{p}(F, \\mathbf{y}; v)= \\sum_{i=1}^{d} \\sum_{j=1}^{d} \\left( \\mathbb{E} | v(\\mathbf{X})_{i} - v(\\mathbf{X})_{j} |^{p} - | v(\\mathbf{y})_{i} - v(\\mathbf{y})_{j} |^{p} \\right)^{2}, \\] <p>where \\(v : \\mathbb{R}^{d} \\to \\mathbb{R}^{d}\\) is a so-called chaining function, so that \\(v(\\mathbf{X}) = (v(\\mathbf{X})_{1}, \\dots, v(\\mathbf{X})_{d}) \\in \\mathbb{R}^{d}\\).  The threshold-weighted variogram score transforms the forecasts and observations according  to the chaining function \\(v\\), prior to calculating the unweighted variogram score. Choosing a chaining function is generally more difficult than choosing a weight function when emphasising particular outcomes.</p> <p>As an alternative, the vertically re-scaled variogram score is defined as </p> \\[\\text{vrVS}_{p}(F, \\mathbf{y}; w) = \\mathbb{E} [ \\rho_{p}(\\mathbf{X}, \\mathbf{y}) w(\\mathbf{X}) w(\\mathbf{y}) ] - \\frac{1}{2} \\mathbb{E} [ \\rho_{p}(\\mathbf{X}, \\mathbf{X}^{\\prime}) w(\\mathbf{X}) w(\\mathbf{X}^{\\prime}) ] + \\left( \\mathbb{E} [ \\rho_{p} ( \\mathbf{X}, \\mathbf{x}_{0} ) w(\\mathbf{X}) ] - \\rho_{p} ( \\mathbf{y}, \\mathbf{x}_{0}) w(\\mathbf{y}) \\right) \\left(\\mathbb{E}[w(\\mathbf{X})] - w(\\mathbf{y}) \\right), \\] <p>where \\(w\\) and \\(\\rho_{p}\\) are as defined above, and \\(\\mathbf{x}_{0} \\in \\mathbb{R}^{d}\\).  Typically, \\(\\mathbf{x}_{0}\\) is chosen to be the zero vector.</p> <p>Each of these weighted variogram scores targets particular outcomes in a different way.  Further details regarding the differences between these scoring rules, as well as choices  for the weight and chaining functions, can be found in Allen et al. (2022). The weighted variogram scores can easily be computed for ensemble forecasts by replacing the expectations with sample means over the ensemble members.</p> <p></p> <ol> <li> <p>Michael Scheuerer and Thomas M. Hamill. Variogram-Based Proper Scoring Rules for Probabilistic Forecasts of Multivariate Quantities. Monthly Weather Review, 2015. URL: https://journals.ametsoc.org/view/journals/mwre/143/4/mwr-d-14-00269.1.xml, doi:10.1175/MWR-D-14-00269.1.\u00a0\u21a9</p> </li> <li> <p>Sam Allen, David Ginsbourger, and Johanna Ziegel. Evaluating forecasts for high-impact events using transformed kernel scores. arXiv preprint arXiv:2202.12732, 2022.\u00a0\u21a9</p> </li> <li> <p>Hajo Holzmann and Bernhard Klar. Focusing on regions of interest in forecast evaluation. The Annals of Applied Statistics, 11:2404\u20132431, 2017.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/variogram/ensemble/","title":"Ensemble-based estimation","text":""},{"location":"api/variogram/ensemble/#scoringrules.variogram_score","title":"<code>scoringrules.variogram_score(forecasts: Array, observations: Array, /, m_axis: int = -2, v_axis: int = -1, *, p: float = 1.0, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the Variogram Score for a finite multivariate ensemble.</p> <p>For a \\(D\\)-variate ensemble the Variogram Score (Sheuerer and Hamill, 2015) of order \\(p\\) is expressed as</p> \\[VS(F, \\mathbf{y}) = \\sum_{i,j=1}^{D}(|y_i - y_j|^p - E_F|X_i - X_j|^p)^2 ,\\] <p>where \\(\\mathbf{X}\\) and \\(\\mathbf{X'}\\) are independently sampled ensembles from from \\(F\\).</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the second last axis and the variables dimension by the last axis.</p> required <code>observations</code> <code>Array</code> <p>The observed values, where the variables dimension is by default the last axis.</p> required <code>p</code> <code>float</code> <p>The order of the Variogram Score. Typical values are 0.5, 1.0 or 2.0. Defaults to 1.0.</p> <code>1.0</code> <code>m_axis</code> <code>int</code> <p>The axis corresponding to the ensemble dimension. Defaults to -2.</p> <code>-2</code> <code>v_axis</code> <code>int</code> <p>The axis corresponding to the variables dimension. Defaults to -1.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>variogram_score</code> <code>Array</code> <p>The computed Variogram Score.</p>"},{"location":"api/variogram/weighted/","title":"Weighted versions","text":""},{"location":"api/variogram/weighted/#scoringrules.owvariogram_score","title":"<code>scoringrules.owvariogram_score(forecasts: Array, observations: Array, w_func: tp.Callable, /, m_axis: int = -2, v_axis: int = -1, *, p: float = 1.0, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the Outcome-Weighted Variogram Score (owVS) for a finite multivariate ensemble.</p> <p>Computation is performed using the ensemble representation of the owVS in Allen et al. (2022):</p> \\[ \\begin{split}     \\mathrm{owVS}(F_{ens}, \\mathbf{y}) = &amp; \\frac{1}{M \\bar{w}} \\sum_{m=1}^{M} \\sum_{i,j=1}^{D}(|y_{i} - y_{j}|^{p} - |x_{m,i} - x_{m,j}|^{p})^{2} w(\\mathbf{x}_{m}) w(\\mathbf{y}) \\\\         &amp; - \\frac{1}{2 M^{2} \\bar{w}^{2}} \\sum_{k,m=1}^{M} \\sum_{i,j=1}^{D} \\left( |x_{k,i} - x_{k,j}|^{p} - |x_{m,i} - x_{m,j}|^{p} \\right)^{2} w(\\mathbf{x}_{k}) w(\\mathbf{x}_{m}) w(\\mathbf{y}), \\end{split} \\] <p>where \\(F_{ens}\\) is the ensemble forecast \\(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{M}\\) with \\(M\\) members, \\(w\\) is the chosen weight function, and \\(\\bar{w} = \\sum_{m=1}^{M}w(\\mathbf{x}_{m})/M\\).</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the second last axis and the variables dimension by the last axis.</p> required <code>observations</code> <code>Array</code> <p>The observed values, where the variables dimension is by default the last axis.</p> required <code>p</code> <code>float</code> <p>The order of the Variogram Score. Typical values are 0.5, 1.0 or 2.0. Defaults to 1.0.</p> <code>1.0</code> <code>w_func</code> <code>Callable</code> <p>Weight function used to emphasise particular outcomes.</p> required <code>m_axis</code> <code>int</code> <p>The axis corresponding to the ensemble dimension. Defaults to -2.</p> <code>-2</code> <code>v_axis</code> <code>int</code> <p>The axis corresponding to the variables dimension. Defaults to -1.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>owvariogram_score</code> <code>ArrayLike of shape (...)</code> <p>The computed Outcome-Weighted Variogram Score.</p>"},{"location":"api/variogram/weighted/#scoringrules.twvariogram_score","title":"<code>scoringrules.twvariogram_score(forecasts: Array, observations: Array, v_func: tp.Callable, /, m_axis: int = -2, v_axis: int = -1, *, p: float = 1.0, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the Threshold-Weighted Variogram Score (twVS) for a finite multivariate ensemble.</p> <p>Computation is performed using the ensemble representation of the twVS in Allen et al. (2022):</p> \\[     \\mathrm{twVS}(F_{ens}, \\mathbf{y}) = \\sum_{i,j=1}^{D}(|v(\\mathbf{y})_i - v(\\mathbf{y})_{j}|^{p} - \\frac{1}{M} \\sum_{m=1}^{M}|v(\\mathbf{x}_{m})_{i} - v(\\mathbf{x}_{m})_{j}|^{p})^{2}, \\] <p>where \\(F_{ens}\\) is the ensemble forecast \\(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{M}\\) with \\(M\\) members, and \\(v\\) is the chaining function used to target particular outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the second last axis and the variables dimension by the last axis.</p> required <code>observations</code> <code>Array</code> <p>The observed values, where the variables dimension is by default the last axis.</p> required <code>p</code> <code>float</code> <p>The order of the Variogram Score. Typical values are 0.5, 1.0 or 2.0. Defaults to 1.0.</p> <code>1.0</code> <code>v_func</code> <code>Callable</code> <p>Chaining function used to emphasise particular outcomes.</p> required <code>m_axis</code> <code>int</code> <p>The axis corresponding to the ensemble dimension. Defaults to -2.</p> <code>-2</code> <code>v_axis</code> <code>int</code> <p>The axis corresponding to the variables dimension. Defaults to -1.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>twvariogram_score</code> <code>ArrayLike of shape (...)</code> <p>The computed Threshold-Weighted Variogram Score.</p>"},{"location":"api/variogram/weighted/#scoringrules.vrvariogram_score","title":"<code>scoringrules.vrvariogram_score(forecasts: Array, observations: Array, w_func: tp.Callable, /, m_axis: int = -2, v_axis: int = -1, *, p: float = 1.0, backend: Backend = None) -&gt; Array</code>","text":"<p>Compute the Vertically Re-scaled Variogram Score (vrVS) for a finite multivariate ensemble.</p> <p>Computation is performed using the ensemble representation of the vrVS in Allen et al. (2022):</p> \\[ \\begin{split}     \\mathrm{vrVS}(F_{ens}, \\mathbf{y}) = &amp; \\frac{1}{M} \\sum_{m=1}^{M} \\sum_{i,j=1}^{D}(|y_{i} - y_{j}|^{p} - |x_{m,i} - x_{m,j}|^{p})^{2} w(\\mathbf{x}_{m}) w(\\mathbf{y}) \\\\         &amp; - \\frac{1}{2 M^{2}} \\sum_{k,m=1}^{M} \\sum_{i,j=1}^{D} \\left( |x_{k,i} - x_{k,j}|^{p} - |x_{m,i} - x_{m,j}|^{p} \\right)^{2} w(\\mathbf{x}_{k}) w(\\mathbf{x}_{m})) \\\\         &amp; + \\left( \\frac{1}{M} \\sum_{m = 1}^{M} \\sum_{i,j=1}^{D}(|x_{m,i} - x_{m,j}|^{p} w(\\mathbf{x}_{m}) - \\sum_{i,j=1}^{D}(|y_{i} - y_{j}|^{p} w(\\mathbf{y}) \\right) \\left( \\frac{1}{M} \\sum_{m = 1}^{M} w(\\mathbf{x}_{m}) - w(\\mathbf{y}) \\right), \\end{split} \\] <p>where \\(F_{ens}\\) is the ensemble forecast \\(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{M}\\) with \\(M\\) members, \\(w\\) is the chosen weight function, and \\(\\bar{w} = \\sum_{m=1}^{M}w(\\mathbf{x}_{m})/M\\).</p> <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>Array</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the second last axis and the variables dimension by the last axis.</p> required <code>observations</code> <code>Array</code> <p>The observed values, where the variables dimension is by default the last axis.</p> required <code>p</code> <code>float</code> <p>The order of the Variogram Score. Typical values are 0.5, 1.0 or 2.0. Defaults to 1.0.</p> <code>1.0</code> <code>w_func</code> <code>Callable</code> <p>Weight function used to emphasise particular outcomes.</p> required <code>m_axis</code> <code>int</code> <p>The axis corresponding to the ensemble dimension. Defaults to -2.</p> <code>-2</code> <code>v_axis</code> <code>int</code> <p>The axis corresponding to the variables dimension. Defaults to -1.</p> <code>-1</code> <code>backend</code> <code>Backend</code> <p>The name of the backend used for computations. Defaults to 'numba' if available, else 'numpy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>vrvariogram_score</code> <code>ArrayLike of shape (...)</code> <p>The computed Vertically Re-scaled Variogram Score.</p>"}]}