{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scoringrules: probabilistic forecast evaluation","text":"<p>Scoringrules is a python library for evaluating probabilistic forecasts by computing scoring rules and other diagnostic quantities. It aims to assist forecasting practitioners not only by providing a set of tools based the scientific literature, but also via its didactic approach.</p>"},{"location":"api/crps/","title":"Continuous Ranked Probability Score","text":"<p>Formally, the CRPS is expressed as</p> \\[\\text{CRPS}(F, y) = \\int_{\\mathbb{R}}[F(x)-\\mathbb{1}\\{y \\le x\\}]^2 dx\\] <p>where \\(F(x) = P(X&lt;x)\\) is the forecast CDF and \\(\\mathbb{1}\\{x \\le y\\}\\) the empirical CDF of the scalar observation \\(y\\). \\(\\mathbb{1}\\) is the indicator function. The CRPS can also be viewed as the Brier score integrated over all real-valued thresholds.</p> <p>Citing directly from the abstract of [CITE]:</p> <p>The continuous ranked probability score (CRPS) is a much used measure of performance for probabilistic forecasts of a scalar observation. It is a quadratic measure of the difference between the forecast cumulative distribution function (CDF) and the empirical CDF of the observation. Analytic formulations of the CRPS can be derived for most classical parametric distributions, and be used to assess the efficiency of different CRPS estimators. When the true forecast CDF is not fully known, but represented as an ensemble of values, the CRPS is estimated with some error.</p> <p>Here we implement multiple CRPS estimators based on a finite ensemble in <code>crps.ensemble()</code>, as well as the analytic formulations of the CRPS for some parametric distributions.</p> <p></p>"},{"location":"api/crps/#ensemble-based-estimators","title":"Ensemble-based estimators","text":""},{"location":"api/crps/#scoringrules.crps.ensemble_int","title":"<code>scoringrules.crps.ensemble_int(forecasts: NDArray, observation: NDArray, axis: int = -1, sorted_ensemble: bool = False)</code>","text":"<p>Compute the Continuous Ranked Probability Score (CRPS).</p> \\[ \\text{CRPS}_{\\text{INT}}(M, y) = \\int_{\\mathbb{R}} \\left[ \\frac{1}{M} \\sum_{i=1}^M \\mathbb{1}\\{x_i \\le x \\} - \\mathbb{1}(y \\le x)  \\right] ^2 dx\\] <p>Parameters:</p> Name Type Description Default <code>forecasts</code> <code>NDArray</code> <p>The predicted forecast ensemble, where the ensemble dimension is by default represented by the last axis.</p> required <code>observation</code> <code>NDArray</code> <p>The observed values.</p> required <code>axis</code> <code>int</code> <p>The axis corresponding to the example. Default is the last axis.</p> <code>-1</code> <code>sorted_ensemble</code> <code>bool</code> <p>Boolean indicating whether the ensemble members are already in ascending order. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>crps</code> <code>NDArray</code> <p>The CRPS between the forecast ensemble and obs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scoringrules import crps\n&gt;&gt;&gt; crps.ensemble(pred, obs)\n</code></pre> Source code in <code>scoringrules/crps.py</code> <pre><code>def ensemble_int(\n    forecasts: NDArray,\n    observation: NDArray,\n    axis: int = -1,\n    sorted_ensemble: bool = False,\n):\nr\"\"\"Compute the Continuous Ranked Probability Score (CRPS).\n\n    $$ \\text{CRPS}_{\\text{INT}}(M, y) = \\int_{\\mathbb{R}} \\left[ \\frac{1}{M}\n    \\sum_{i=1}^M \\mathbb{1}\\{x_i \\le x \\} - \\mathbb{1}(y \\le x)  \\right] ^2 dx$$\n\n\n    Parameters\n    ----------\n    forecasts: NDArray\n        The predicted forecast ensemble, where the ensemble dimension is by default\n        represented by the last axis.\n    observation: NDArray\n        The observed values.\n    axis: int, optional\n        The axis corresponding to the example. Default is the last axis.\n    sorted_ensemble: bool, optional\n        Boolean indicating whether the ensemble members are already in ascending order.\n        Default is False.\n\n    Returns\n    -------\n    crps: NDArray\n        The CRPS between the forecast ensemble and obs.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from scoringrules import crps\n    &gt;&gt;&gt; crps.ensemble(pred, obs)\n    \"\"\"\n    if not sorted_ensemble:\n        forecasts = np.sort(forecasts, axis=axis)\n\n    return _ensemble_int_gufunc_alt(forecasts, observation)\n</code></pre>"},{"location":"api/crps/#analytical-formulations","title":"Analytical formulations","text":""},{"location":"api/crps/#scoringrules.crps.normal","title":"<code>scoringrules.crps.normal(mu: NDArray, sigma: NDArray, observation: NDArray)</code>","text":"<p>Compute the closed form of the CRPS for the normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>NDArray</code> <p>Mean of the forecast normal distribution.</p> required <code>sigma</code> <code>NDArray</code> <p>Standard deviation of the forecast normal distribution.</p> required <code>observation</code> <code>NDArray</code> <p>The observed values.</p> required <p>Returns:</p> Name Type Description <code>crps</code> <code>array_like</code> <p>The CRPS between Normal(mu, sigma) and obs.</p> Source code in <code>scoringrules/crps.py</code> <pre><code>def normal(mu: NDArray, sigma: NDArray, observation: NDArray):\n\"\"\"Compute the closed form of the CRPS for the normal distribution.\n\n    Parameters\n    ----------\n    mu: NDArray\n        Mean of the forecast normal distribution.\n    sigma: NDArray\n        Standard deviation of the forecast normal distribution.\n    observation: NDArray\n        The observed values.\n\n    Returns\n    -------\n    crps: array_like\n        The CRPS between Normal(mu, sigma) and obs.\n    \"\"\"\n    sx = (observation - mu) / sigma\n    crps = sigma * (sx * (2 * norm.cdf(sx) - 1) + 2 * norm.pdf(sx) - 1 / np.sqrt(np.pi))\n    return crps\n</code></pre>"},{"location":"api/crps/#scoringrules.crps.lognormal","title":"<code>scoringrules.crps.lognormal(mu, sigma, obs)</code>","text":"<p>Compute the closed form of the CRPS for the lognormal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <p>Mean of the normal distribution.</p> required <code>sigma</code> <p>Standard deviation of the normal distribution.</p> required <p>Returns:</p> Name Type Description <code>crps</code> <code>array_like</code> <p>The CRPS between Lognormal(mu, sigma) and obs.</p> Source code in <code>scoringrules/crps.py</code> <pre><code>def lognormal(mu, sigma, obs):\n\"\"\"Compute the closed form of the CRPS for the lognormal distribution.\n\n    Parameters\n    ----------\n    mu: array_like\n        Mean of the normal distribution.\n    sigma: array_like\n        Standard deviation of the normal distribution.\n\n    Returns\n    -------\n    crps: array_like\n        The CRPS between Lognormal(mu, sigma) and obs.\n    \"\"\"\n    sx = (np.log(obs) - mu) / sigma\n    ex = 2 * np.exp(mu + sigma**2 / 2)\n    crps = obs * (2 * norm.cdf(sx) - 1) - ex * (\n        norm.cdf(sx - sigma) + norm.cdf(sigma / np.sqrt(2)) - 1\n    )\n    return crps\n</code></pre>"}]}